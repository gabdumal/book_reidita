---
title: Efeitos
author: Gabriel Malosto
---

import { Aside } from "@astrojs/starlight/components";
import Figure from "/src/components/Figure.astro";

import production from "/src/assets/content/docs/course/effects/production.png";

Exploramos o aspecto _clicker_ do jogo em mais de um recurso.
Por√©m, o g√™nero _Idle Clicker_ se fundamenta em um outro elemento: o ganho de pontos por segundo.

## Adaptando a interface

Precisamos adaptar o estado e a interface do jogo para que o jogador possa ver a quantidade de pontos ganhos por segundo.

1. Atualize a defini√ß√£o da interface `Resource` para incluir um campo `production`.

```ts
/* types.ts */

export interface Resource {
  name: string;
  icon: string;
  amount: number;
  production: number;
}
```

2. Atualize o estado inicial do jogo para incluir a produ√ß√£o de recursos por segundo.

```tsx
/* App.tsx */

const [resources, setResources] = useState<Resources>({
  wood: {
    name: "Madeira",
    icon: "üå≥",
    amount: 0,
    production: 0,
  },
  coin: {
    name: "Moeda",
    icon: "ü™ô",
    amount: 0,
    production: 0,
  },
  house: {
    name: "Casa",
    icon: "üè†",
    amount: 0,
    production: 0,
  },
  worker: {
    name: "Trabalhador",
    icon: "üë∑",
    amount: 0,
    production: 0,
  },
});
```

3. Atualize o componente `ResourceDisplay` para exibir a produ√ß√£o de recursos por segundo.

```tsx
/* ResourceDisplay.tsx */

<div className={styles.data}>
  <p className={styles.amount}>{resource.amount}</p>
  <p className={styles.production}>{resource.production} / s</p>
</div>
```

4. Atualize o arquivo `ResourceDisplay.module.css` para estilizar o componente com o novo campo de produ√ß√£o.

```css
.box {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  gap: 0.25rem;
  min-height: 8.5rem;
  min-width: 8.5rem;
  border-radius: 0.75rem;
  background-color: white;
  &:global {
    animation: box-shadow-color-transform 30s cubic-bezier(0.4, 0, 0.6, 1)
      infinite;
  }
}

.name {
  margin: 0;
  font-weight: 900;
  font-size: 1.25rem;
}

.icon {
  font-size: 3rem;
}

.data {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0;
}

.amount {
  margin: 0;
  font-weight: 900;
}

.production {
  margin: 0;
  font-size: 0.75rem;
  font-weight: 600;
}
```

O resultado final deve ser como o seguinte:

<Figure
  caption="Interface do jogo com produ√ß√£o de recursos por segundo"
  images={[
    {
      src: production,
      alt: "P√°gina do jogo, em que os recursos Madeira, Moeda, Casa e Trabalhador possuem dois campos para os valores: quantidade e produ√ß√£o por segundo.",
    },
  ]}
/>

Agora que temos a produ√ß√£o armazenada num estado, precisamos criar um sistema que atualize os recursos com o tempo.
Felizmente, o JavaScript nos permite criar um sistema de intervalos que executam uma fun√ß√£o a cada _n_ milissegundos.

```js
let pontos = 0;

function ganharPonto() {
  pontos++;
  console.log(pontos);
}

setInterval(ganharPonto, 1000);
```

Por√©m, no React, n√≥s n√£o podemos chamar essa fun√ß√£o diretamente no componente.
Isso ocorre porque, toda vez que o estado atualiza, e o componente √© renderizado novamente, todas as fun√ß√µes chamadas em seu escopo s√£o disparadas novamente.
Isso faria com que v√°rios intervalos fossem criados simultaneamente.

## Hook useEffect

Para resolver esse problema, podemos usar um outro hook do React: o `useEffect`.

<Aside type="note">
  O hook [**useEffect**](https://pt-br.react.dev/reference/react/useEffect) nos
  permite executar efeitos colaterais em componentes funcionais. Isto √©,
  associamos a um estado ou propriedade do componente uma fun√ß√£o que ser√°
  executada quando este for atualizado. Isso permite sincroniz√°-lo com sistemas
  externos.
</Aside>

Quando n√£o especificamos um objeto para o `useEffect` se associar, o React executar√° a fun√ß√£o somente ap√≥s a renderiza√ß√£o inicial do componente.
Isso garante que o intervalo ser√° definido apenas uma vez.

1. Use o m√©todo `useEffect` no componente `App`, logo abaixo da chamada do `useState`. Ao atualizar a p√°gina, uma mensagem ser√° exibida no console.

```tsx
/* App.tsx */

import { useEffect, useState } from "react";

// ...

useEffect(() => {
  console.log("Efeito iniciado");
}, []);
```

2. Crie uma fun√ß√£o `produceResources`, ent√£o a chame logo em seguida.

```tsx
useEffect(() => {
  const produceResources = () => {
    console.log("Produzindo recursos...");
  };
  produceResources();
}, []);
```

3. Substitua a chamada da fun√ß√£o pela inicializa√ß√£o de um intervalo de 1 segundo. Isso imprimir√° a mensagem a cada segundo.

```tsx
useEffect(() => {
  const produceResources = () => {
    console.log("Produzindo recursos...");
  };

  const interval = setInterval(produceResources, 1000);
  return () => clearInterval(interval);
}, []);
```

<Aside>
  O retorno da fun√ß√£o passada ao `useEffect` √© chamado de fun√ß√£o de limpeza. Ela
  √© executada quando o componente √© desmontado, ou quando o `useEffect` √©
  chamado novamente. No caso do intervalo, a fun√ß√£o de limpeza √© respons√°vel por
  cancel√°-lo, evitando que mais um seja disparado toda vez que o componente for
  montado.
</Aside>

5. Fora do `useEffect`, crie uma fun√ß√£o que recebe um recurso, calcula a quantidade nova no estoque, e retorna um novo objeto modificado.

```tsx
const produceResource = (resource: Resource) => {
  let newAmount = resource.amount + resource.production;
  if (newAmount < 0) newAmount = 0;
  return {
    ...resource,
    amount: newAmount,
  };
};
```

6. Atualize a fun√ß√£o `produceResources` para retornar o estoque de recursos atualizado.

```tsx
useEffect(() => {
  const produceResources = () => {
    setResources((resources: Resources) => {
      const updatedResources: Resources = {
        wood: produceResource(resources.wood),
        coin: produceResource(resources.coin),
        house: produceResource(resources.house),
        worker: produceResource(resources.worker),
      };
      return updatedResources;
    });
  };

  const interval = setInterval(produceResources, 1000);
  return () => clearInterval(interval);
}, []);
```

Para testar, mude o valor de produ√ß√£o do recurso `wood` para 1 e recarregue a p√°gina.
Possivelmente voc√™ ver√° a quantidade de madeira aumentar em duas unidades em vez de uma s√≥.
Isso ocorre pois, no modo de desenvolvimento, o React monta o componente, desmonta-o e monta novamente, a fim de testar se a l√≥gica de implementa√ß√£o est√° correta.
