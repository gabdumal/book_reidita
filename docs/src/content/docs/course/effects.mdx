---
title: Efeitos
author: Gabriel Malosto
---

import { Aside } from "@astrojs/starlight/components";
import Figure from "/src/components/Figure.astro";

import production from "/src/assets/content/docs/course/effects/production.png";

Exploramos o aspecto _clicker_ do jogo em mais de um recurso.
Por√©m, o g√™nero _Idle Clicker_ se fundamenta em um outro elemento: o ganho de pontos por segundo.

## Adaptando a interface

Precisamos adaptar o estado e a interface do jogo para que o jogador possa ver a quantidade de pontos ganhos por segundo.

1. Atualize a defini√ß√£o da interface `Resource` para incluir um campo `production`.

```ts
/* types.ts */

export interface Resource {
  name: string;
  icon: string;
  amount: number;
  production: number;
}
```

2. Atualize o estado inicial do jogo para incluir a produ√ß√£o de recursos por segundo.

```tsx
/* App.tsx */

const [resources, setResources] = useState<Resources>({
  wood: {
    name: "Madeira",
    icon: "üå≥",
    amount: 0,
    production: 0,
  },
  coin: {
    name: "Moeda",
    icon: "ü™ô",
    amount: 0,
    production: 0,
  },
  house: {
    name: "Casa",
    icon: "üè†",
    amount: 0,
    production: 0,
  },
  worker: {
    name: "Trabalhador",
    icon: "üë∑",
    amount: 0,
    production: 0,
  },
});
```

3. Atualize o componente `ResourceDisplay` para exibir a produ√ß√£o de recursos por segundo.

```tsx
/* ResourceDisplay.tsx */

<div className={styles.data}>
  <p className={styles.amount}>{resource.amount}</p>
  <p className={styles.production}>{resource.production} / s</p>
</div>
```

4. Atualize o arquivo `ResourceDisplay.module.css` para estilizar o componente com o novo campo de produ√ß√£o.

```css
.box {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  gap: 0.25rem;
  min-height: 8.5rem;
  min-width: 8.5rem;
  border-radius: 0.75rem;
  background-color: white;
  &:global {
    animation: box-shadow-color-transform 30s cubic-bezier(0.4, 0, 0.6, 1)
      infinite;
  }
}

.name {
  margin: 0;
  font-weight: 900;
  font-size: 1.25rem;
}

.icon {
  font-size: 3rem;
}

.data {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0;
}

.amount {
  margin: 0;
  font-weight: 900;
}

.production {
  margin: 0;
  font-size: 0.75rem;
  font-weight: 600;
}
```

O resultado final deve ser como o seguinte:

<Figure
  caption="Interface do jogo com produ√ß√£o de recursos por segundo"
  images={[
    {
      src: production,
      alt: "P√°gina do jogo, em que os recursos Madeira, Moeda, Casa e Trabalhador possuem dois campos para os valores: quantidade e produ√ß√£o por segundo.",
    },
  ]}
/>

Agora que temos a produ√ß√£o armazenada num estado, precisamos criar um sistema que atualize os recursos com o tempo.
Felizmente, o JavaScript nos permite criar um sistema de intervalos que executam uma fun√ß√£o a cada _n_ milissegundos.

```js
let pontos = 0;

function ganharPonto() {
  pontos++;
  console.log(pontos);
}

setInterval(ganharPonto, 1000);
```

Por√©m, no React, n√≥s n√£o podemos chamar essa fun√ß√£o diretamente no componente.
Isso ocorre porque, toda vez que o estado atualiza, e o componente √© renderizado novamente, todas as fun√ß√µes chamadas em seu escopo s√£o disparadas novamente.
Isso faria com que v√°rios intervalos fossem criados simultaneamente.

## Hook useEffect

Para resolver esse problema, podemos usar um outro hook do React: o `useEffect`.

<Aside type="note">
  O hook [**useEffect**](https://pt-br.react.dev/reference/react/useEffect) nos
  permite executar efeitos colaterais em componentes funcionais. Isto √©,
  associamos a um estado ou propriedade do componente uma fun√ß√£o que ser√°
  executada quando este for atualizado. Isso permite sincroniz√°-lo com sistemas
  externos.
</Aside>
