---
title: Efeitos
author: Gabriel Malosto
---

import { Aside } from "@astrojs/starlight/components";
import Figure from "/src/components/Figure.astro";

import production from "/src/assets/content/docs/course/effects/production.png";

Exploramos o aspecto _clicker_ do jogo em mais de um recurso.
Por√©m, o g√™nero _Idle Clicker_ se fundamenta em um outro elemento: o ganho de pontos por segundo.

## Adaptando a interface

Precisamos adaptar o estado e a interface do jogo para que o jogador possa ver a quantidade de pontos ganhos por segundo.

1. Atualize a defini√ß√£o da interface `Resource` para incluir um campo `production`.

```ts
/* types.ts */

export interface Resource {
  name: string;
  icon: string;
  amount: number;
  production: number;
}
```

2. Atualize o estado inicial do jogo para incluir a produ√ß√£o de recursos por segundo.

```tsx
/* App.tsx */

const [resources, setResources] = useState<Resources>({
  wood: {
    name: "Madeira",
    icon: "üå≥",
    amount: 0,
    production: 0,
  },
  coin: {
    name: "Moeda",
    icon: "ü™ô",
    amount: 0,
    production: 0,
  },
  house: {
    name: "Casa",
    icon: "üè†",
    amount: 0,
    production: 0,
  },
  worker: {
    name: "Trabalhador",
    icon: "üë∑",
    amount: 0,
    production: 0,
  },
});
```

3. Atualize o componente `ResourceDisplay` para exibir a produ√ß√£o de recursos por segundo.

```tsx
/* ResourceDisplay.tsx */

return (
  <div className={styles.box}>
    <h1 className={styles.name}>{resource.name}</h1>
    <span className={styles.icon}>{resource.icon}</span>
    <div className={styles.data}>
      <p className={styles.amount}>{resource.amount}</p>
      <p className={styles.production}>{resource.production} / s</p>
    </div>
  </div>
);
```

4. Atualize o arquivo `ResourceDisplay.module.css` para estilizar o componente com o novo campo de produ√ß√£o.

```css
/* ResourceDisplay.module.css */

.box {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  gap: 0.25rem;
  min-height: 8.5rem;
  min-width: 8.5rem;
  border-radius: 0.75rem;
  background-color: white;
  &:global {
    animation: box-shadow-color-transform 30s cubic-bezier(0.4, 0, 0.6, 1)
      infinite;
  }
}

.name {
  margin: 0;
  font-weight: 900;
  font-size: 1.25rem;
}

.icon {
  font-size: 3rem;
}

.data {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0;
}

.amount {
  margin: 0;
  font-weight: 900;
}

.production {
  margin: 0;
  font-size: 0.75rem;
  font-weight: 600;
}
```

O resultado final deve ser como o seguinte:

<Figure
  caption="Interface do jogo com produ√ß√£o de recursos por segundo"
  images={[
    {
      src: production,
      alt: "P√°gina do jogo, em que os recursos Madeira, Moeda, Casa e Trabalhador possuem dois campos para os valores: quantidade e produ√ß√£o por segundo.",
    },
  ]}
/>

Agora que temos a produ√ß√£o armazenada num estado, precisamos criar um sistema que atualize os recursos com o tempo.
Felizmente, o JavaScript nos permite criar um sistema de intervalos que executam uma fun√ß√£o a cada _n_ milissegundos.

```js
let pontos = 0;

function ganharPonto() {
  pontos++;
  console.log(pontos);
}

setInterval(ganharPonto, 1000);
```

Por√©m, no React, n√≥s n√£o podemos chamar essa fun√ß√£o diretamente no componente.
Isso ocorre porque, toda vez que o estado atualiza, e o componente √© renderizado novamente, todas as fun√ß√µes chamadas em seu escopo s√£o disparadas novamente.
Isso faria com que v√°rios intervalos fossem criados simultaneamente.

## Hook useEffect

Para resolver esse problema, podemos usar um outro hook do React: o `useEffect`.

<Aside type="note">
  O hook [**useEffect**](https://pt-br.react.dev/reference/react/useEffect) nos
  permite executar efeitos colaterais em componentes funcionais. Isto √©,
  associamos a um estado ou propriedade do componente uma fun√ß√£o que ser√°
  executada quando este for atualizado. Isso permite sincroniz√°-lo com sistemas
  externos.
</Aside>

Quando n√£o especificamos um objeto para o `useEffect` se associar, o React executar√° a fun√ß√£o somente ap√≥s a renderiza√ß√£o inicial do componente.
Isso garante que o intervalo ser√° definido apenas uma vez.

1. Use o m√©todo `useEffect` no componente `App`, logo abaixo da chamada do `useState`. Ao atualizar a p√°gina, uma mensagem ser√° exibida no console.

```tsx
/* App.tsx */

import { useEffect, useState } from "react";

// ...

useEffect(() => {
  console.log("Efeito iniciado");
}, []);
```

2. Crie uma fun√ß√£o `produceResources`, ent√£o a chame logo em seguida.

```tsx
/* App.tsx */

useEffect(() => {
  const produceResources = () => {
    console.log("Produzindo recursos...");
  };
  produceResources();
}, []);
```

3. Substitua a chamada da fun√ß√£o pela inicializa√ß√£o de um intervalo de 1 segundo. Isso imprimir√° a mensagem a cada segundo.

```tsx
/* App.tsx */

useEffect(() => {
  const produceResources = () => {
    console.log("Produzindo recursos...");
  };

  const interval = setInterval(produceResources, 1000);
  return () => clearInterval(interval);
}, []);
```

<Aside>
  O retorno da fun√ß√£o passada ao `useEffect` √© chamado de fun√ß√£o de limpeza. Ela
  √© executada quando o componente √© desmontado, ou quando o `useEffect` √©
  chamado novamente. No caso do intervalo, a fun√ß√£o de limpeza √© respons√°vel por
  cancel√°-lo, evitando que mais um seja disparado toda vez que o componente for
  montado.
</Aside>

5. **Antes** do `useEffect`, crie uma fun√ß√£o que recebe um recurso, calcula a quantidade nova no estoque, e retorna um novo objeto modificado.

```tsx
/* App.tsx */

const produceResource = (resource: Resource) => {
  let newAmount = resource.amount + resource.production;
  if (newAmount < 0) newAmount = 0;
  return {
    ...resource,
    amount: newAmount,
  };
};
```

6. Atualize a fun√ß√£o `produceResources` para retornar o estoque de recursos atualizado.

```tsx
/* App.tsx */

useEffect(() => {
  const produceResources = () => {
    setResources((resources: Resources) => {
      const updatedResources: Resources = {
        wood: produceResource(resources.wood),
        coin: produceResource(resources.coin),
        house: produceResource(resources.house),
        worker: produceResource(resources.worker),
      };
      return updatedResources;
    });
  };

  const interval = setInterval(produceResources, 1000);
  return () => clearInterval(interval);
}, []);
```

Para testar, mude o valor de produ√ß√£o do recurso `wood` para 1 e recarregue a p√°gina.
Voc√™ ver√° que a quantidade de madeira aumenta a cada segundo.

## Alterando a produ√ß√£o

Assim como fizemos com a quantidade de recursos no estoque, podemos aprimorar as estruturas de dados para aumentar a produ√ß√£o de um recurso quando executamos uma a√ß√£o.

Vamos fazer isso para representar que, ao contratar um trabalhador, a produ√ß√£o de madeira aumenta, j√° que ele estar√° cortando as √°rvores.

1. Atualize a defini√ß√£o da interface `Trade` para incluir um campo `production`.

```ts
/* types.ts */

export interface Trade {
  resourceType: ResourceType;
  amount: number;
  production: number;
}
```

2. No componente `ActionsContainer`, atualize **todos** os atributos `trades` para definir a produ√ß√£o como 0.

```tsx
/* ActionsContainer.tsx */

const actions: Actions = {
  chopWood: {
    name: "Cortar Madeira",
    icon: "ü™ì",
    trades: [{ resourceType: ResourceType.wood, amount: +1, production: 0 }],
  },
  sellWood: {
    name: "Vender Madeira",
    icon: "üí∞",
    trades: [
      { resourceType: ResourceType.wood, amount: -1, production: 0 },
      { resourceType: ResourceType.coin, amount: +1, production: 0 },
    ],
  },
  buildHouse: {
    name: "Construir Casa",
    icon: "üõ†Ô∏è",
    trades: [
      { resourceType: ResourceType.wood, amount: -5, production: 0 },
      { resourceType: ResourceType.coin, amount: -5, production: 0 },
      { resourceType: ResourceType.house, amount: +1, production: 0 },
    ],
  },
  hireWorker: {
    name: "Contratar Trabalhador",
    icon: "üßæ",
    trades: [
      { resourceType: ResourceType.coin, amount: -10, production: 0 },
      { resourceType: ResourceType.house, amount: -1, production: 0 },
      { resourceType: ResourceType.worker, amount: +1, production: 0 },
    ],
  },
};
```

3. Para o atributo `hireWorker`, crie uma nova troca, cuja produ√ß√£o de madeira seja 1.

```tsx
/* ActionsContainer.tsx */

// ...

hireWorker: {
  name: "Contratar Trabalhador",
  icon: "üßæ",
  trades: [
    { resourceType: ResourceType.wood, amount: 0, production: 1 },
    { resourceType: ResourceType.coin, amount: -10, production: 0 },
    { resourceType: ResourceType.house, amount: -1, production: 0 },
    { resourceType: ResourceType.worker, amount: +1, production: 0 },
  ],
},

// ...
```

4. Atualize a fun√ß√£o `performTrade` no componente `ActionButton` para atualizar a produ√ß√£o dos recursos.

```tsx
/* ActionButton.tsx */

const performTrade = () => {
  let tradeIsPossible = true;
  const updatedResources = { ...resources };

  action.trades.forEach(({ resourceType, amount, production }) => {
    const resource = { ...updatedResources[resourceType] };

    const newAmount = resource.amount + amount;
    const newProduction = resource.production + production;

    tradeIsPossible = tradeIsPossible && newAmount >= 0;
    tradeIsPossible = tradeIsPossible && newProduction >= 0;

    resource.amount = newAmount;
    resource.production = newProduction;
    updatedResources[resourceType] = resource;
  });

  if (tradeIsPossible) setResources(updatedResources);
};
```

Agora, ao contratar um trabalhador, a produ√ß√£o de madeira aumentar√° em 1 unidade por segundo.
